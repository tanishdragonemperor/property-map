public with sharing class NearbyRecordsHandler { // Configuration for different object types - easily extensible private static Map<String, ObjectConfig> objectConfigs = new Map<String, ObjectConfig>{ 'lead' => new ObjectConfig( 'Lead', new List<String>{'Property_Name__c', 'Property_Address__c', 'Property_Age_In_Years__c'}, new Map<String, String>{'Property_Name__c' => 'Lead Name', 'Property Address' => 'Property_Address__c', 'Property Age (In Years)' => 'Property_Age_In_Years__c'}, 'Property_Latitude__c', 'Property_Longitude__c', '00Q' ), 'property' => new ObjectConfig( 'Property__c', new List<String>{'Name', 'Source_Contact_First_Name__c', 'Source_Contact_Last_Name__c', 'apiCount__c'}, new Map<String, String>{'Name' => 'Lead Name', 'Source_Contact_First_Name__c' => 'Source Contact First Name', 'Source_Contact_Last_Name__c' => 'Source Contact Last Name', 'apiCount' => 'apiCount__c'}, 'Latitude__c', 'Longitude__c', 'a0A' ) }; public class ObjectConfig { public String objectApiName; public List<String> displayFields; public Map<String, String> fieldLabels; public String latitudeField; public String longitudeField; public String recordPrefix; public ObjectConfig(String objectApiName, List<String> displayFields, Map<String, String> fieldLabels, String latitudeField, String longitudeField, String recordPrefix) { this.objectApiName = objectApiName; this.displayFields = displayFields; this.fieldLabels = fieldLabels; this.latitudeField = latitudeField; this.longitudeField = longitudeField; this.recordPrefix = recordPrefix; } } public class InputWrapper { @InvocableVariable public String userPrompt; @InvocableVariable public String recordId; } public class OutputWrapper { @InvocableVariable public String result; } @InvocableMethod(label='Find Nearby Records') public static List<OutputWrapper> getNearby(List<InputWrapper> inputs) { InputWrapper input = inputs[0]; String prompt = input.userPrompt != null ? input.userPrompt.toLowerCase() : ''; String recordId = input.recordId; if (String.isBlank(recordId)) { return wrap('‚ùå No recordId found.'); } // Determine object type from prompt or record ID String objectType = determineObjectType(prompt, recordId);//property or lead if (objectType == null) { return wrap('‚ùå Could not identify target object. Supported objects: ' + String.join(objectConfigs.keySet(), ', ')); } // Extract radius from prompt Decimal radius = extractRadius(prompt); System.debug('QQQ'+ radius); // Get current record coordinates RecordLocation currentLocation = getCurrentRecordLocation(recordId, objectType); if (currentLocation == null) { return wrap('‚ùå Could not retrieve location data for current record.'); } System.debug('QQQ'+ 'currentLocation'); System.debug('QQQ'+ currentLocation); // Find nearby records List<Map<String, Object>> nearbyRecords = findNearbyRecords(objectType, currentLocation, radius, recordId); System.debug('QQQ'+ 'nearbyRecords'); System.debug('QQQ'+ nearbyRecords); // Build and return result String result = buildResultString(nearbyRecords, currentLocation, objectType, radius); return wrap(result); } private static String determineObjectType(String prompt, String recordId) { // First check prompt for explicit object mention for (String objectType : objectConfigs.keySet()) { if (prompt.contains(objectType)) { return objectType; } } // Fallback to record ID prefix String prefix = recordId.left(3); for (String objectType : objectConfigs.keySet()) { if (objectConfigs.get(objectType).recordPrefix == prefix) { return objectType; } } return null; } private static Decimal extractRadius(String prompt) { Pattern p = Pattern.compile('(\\d+\\.?\\d*)\\s*mile'); Matcher m = p.matcher(prompt); return m.find() ? Decimal.valueOf(m.group(1)) : 10; // Default 10 miles } private static RecordLocation getCurrentRecordLocation(String recordId, String objectType) { ObjectConfig config = objectConfigs.get(objectType); System.debug('QQQ'+ 'config get current location'); System.debug('QQQ'+ config); try { String query = 'SELECT Name, ' + config.latitudeField + ', ' + config.longitudeField + ' FROM ' + config.objectApiName + ' WHERE Id = :recordId LIMIT 1'; SObject record = Database.query(query)[0]; return new RecordLocation( (String) record.get('Name'), (Decimal) record.get(config.latitudeField), (Decimal) record.get(config.longitudeField) ); } catch (Exception e) { System.debug('Error retrieving current record location: ' + e.getMessage()); return null; } } private static List<Map<String, Object>> findNearbyRecords(String objectType, RecordLocation currentLocation, Decimal radius, String excludeRecordId) { ObjectConfig config = objectConfigs.get(objectType); System.debug('QQQ'+ 'config findNearbyRecords'); System.debug('QQQ'+ config); List<Map<String, Object>> records = new List<Map<String, Object>>(); System.debug('QQQ'+ 'records FindnearbyRecords'); System.debug('QQQ'+ records); // Build dynamic query with display fields String fields = String.join(config.displayFields, ', '); String query = 'SELECT Id, ' + fields + ', ' + config.latitudeField + ', ' + config.longitudeField + ' FROM ' + config.objectApiName + ' WHERE Id != :excludeRecordId AND ' + config.latitudeField + ' != null AND ' + config.longitudeField + ' != null' + ' LIMIT 200'; // Reasonable limit for distance calculation Map<String, Object> bindVars = new Map<String, Object>{'excludeRecordId' => excludeRecordId}; for (SObject record : Database.queryWithBinds(query, bindVars, AccessLevel.USER_MODE)) { Decimal lat = (Decimal) record.get(config.latitudeField); Decimal lng = (Decimal) record.get(config.longitudeField); System.debug('QQQ'+ 'record FindnearbyRecords'); System.debug('QQQ'+ record); Double distance = haversine(currentLocation.latitude, currentLocation.longitude, lat, lng); if (distance <= radius) { Map<String, Object> recordData = new Map<String, Object>{ 'id' => record.Id, 'name' => (String) record.get('Name'), 'distance' => distance, 'latitude' => lat, 'longitude' => lng, 'fields' => new Map<String, Object>() }; System.debug('QQQ'+ ' RecordData FindnearbyRecords'); System.debug('QQQ'+ recordData); System.debug('QQQ'+ 'Config FindnearbyRecords nefore the for loop for geting record data in line 171'); System.debug('QQQ'+ config); // Add display fields for (String field : config.displayFields) { ((Map<String, Object>) recordData.get('fields')).put(field, record.get(field)); } records.add(recordData); } } // Sort by distance records.sort(new DistanceComparator()); // Return max 30 records if (records.size() > 30) { List<Map<String, Object>> result = new List<Map<String, Object>>(); for (Integer i = 0; i < 30; i++) { result.add(records[i]); } return result; } return records; } private static String buildResultString(List<Map<String, Object>> records, RecordLocation currentLocation, String objectType, Decimal radius) { ObjectConfig config = objectConfigs.get(objectType); List<String> resultLines = new List<String>(); if (records.isEmpty()) { return '‚ùå No ' + objectType + 's found within ' + radius + ' miles.'; } // Start with clean HTML structure resultLines.add('<div>'); resultLines.add('<p><strong>üìç Found ' + records.size() + ' ' + objectType + '(s) within ' + radius + ' miles:</strong></p>'); Integer displayLimit = Math.min(records.size(), 30); for (Integer i = 0; i < displayLimit; i++) { Map<String, Object> record = records[i]; String recordName = (String) record.get('name'); String recordId = (String) record.get('id'); Double distance = (Double) record.get('distance'); Map<String, Object> fields = (Map<String, Object>) record.get('fields'); resultLines.add('<div style="margin-bottom: 15px; padding: 10px; border-left: 2px solid #0070d2;">'); // Main record link resultLines.add('<p>‚Ä¢ <a href="/lightning/r/' + recordId + '/view" target="_blank">' + String.escapeSingleQuotes(recordName) + '</a></p>'); // Add display fields for (String field : config.displayFields) { if (field != 'Name' && fields.get(field) != null) { String fieldLabel = config.fieldLabels.get(field); Object fieldValue = fields.get(field); resultLines.add('<p style="margin-left: 20px; color: #666; font-size: 0.9em;">' + fieldLabel + ': ' + String.valueOf(fieldValue) + '</p>'); } } resultLines.add('<p style="margin-left: 20px; color: #666; font-size: 0.9em;">Distance: ' + Decimal.valueOf(distance).setScale(2) + ' miles</p>'); resultLines.add('</div>'); } // Generate map URL String mapUrl = generateMapUrl(records, currentLocation, displayLimit); resultLines.add('<p style="text-align: center; margin-top: 20px;">'); resultLines.add('<a href="' + mapUrl + '" target="_blank" style="background-color: #0070d2; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;">üìç View All on Map</a>'); resultLines.add('</p>'); resultLines.add('</div>'); return String.join(resultLines, ''); } private static String generateMapUrl(List<Map<String, Object>> records, RecordLocation currentLocation, Integer lim) { List<Map<String, Object>> markerList = new List<Map<String, Object>>(); // Add current location marker markerList.add(new Map<String, Object>{ 'name' => currentLocation.name + ' (Current)', 'lat' => currentLocation.latitude, 'lng' => currentLocation.longitude, 'color' => 'red' }); // Add nearby records markers for (Integer i = 0; i < lim; i++) { Map<String, Object> record = records[i]; markerList.add(new Map<String, Object>{ 'name' => (String) record.get('name'), 'lat' => record.get('latitude'), 'lng' => record.get('longitude'), 'color' => 'blue' }); } String encoded = EncodingUtil.urlEncode(JSON.serialize(markerList), 'UTF-8'); return 'https://tanishdragonemperor.github.io/property-map/map.html?lat=' + currentLocation.latitude + '&lng=' + currentLocation.longitude + '&markers=' + encoded; } private static Double haversine(Decimal lat1, Decimal lon1, Decimal lat2, Decimal lon2) { Double R = 3958.8; // Radius of Earth in miles Double dLat = ((Double)(lat2 - lat1)) * (Math.PI / 180); Double dLon = ((Double)(lon2 - lon1)) * (Math.PI / 180); Double lat1Rad = ((Double)lat1) * (Math.PI / 180); Double lat2Rad = ((Double)lat2) * (Math.PI / 180); Double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(dLon / 2) * Math.sin(dLon / 2); Double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c; } private static List<OutputWrapper> wrap(String result) { OutputWrapper output = new OutputWrapper(); output.result = result; return new List<OutputWrapper>{ output }; } // Helper classes public class RecordLocation { public String name; public Decimal latitude; public Decimal longitude; public RecordLocation(String name, Decimal latitude, Decimal longitude) { this.name = name; this.latitude = latitude; this.longitude = longitude; } } private class DistanceComparator implements Comparator<Map<String, Object>> { public Integer compare(Map<String, Object> a, Map<String, Object> b) { Double distA = (Double) a.get('distance'); Double distB = (Double) b.get('distance'); return distA < distB ? -1 : (distA > distB ? 1 : 0); } } }